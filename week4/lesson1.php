<!--Содержимое тем 4 неделю
    Что такое массив

    Что такое многомерные массив
    Ассоциативные массив
    Интерполяция элементов массива встрок
    Слияние и сравнение массиво
    Конструкция list

    Обход массива циклом for и foreach
    Проверка существования и удаление элементов массива-->
<?php
// Массивы это списки или коллекции элементов

//$fruits = ['apple', 'orange', 'banana'];
//print_r($fruits);


// Массивы могут содержать элементы разных типов

//$array = [1, true, null, 'text'];
//var_dump($array);

// Лучше так не делать, для этого есть ассоциативные массивы


// Создание массива

//$empty = [];
//$empty = array();

/*
Порядковый номер элемента массива - индекс
Индексация начинается с нуля
У певрого элемента индекс - 0
Для указания индекса конкретного элемента используются квадратные скобки
*/

//$fruits = ['apple', 'orange', 'banana'];
//echo $fruits[0].'<br>';
//echo $fruits[1] . '<br>';
//echo $fruits[3] . '<br>';
//echo $fruits[2] . '<br>';


/*
Индекс последнего элемента всегда меньше на единицу размера массива (размер = кол-во элементов)
*/

//$fruits = ['apple', 'orange', 'banana'];
//echo count($fruits) .'<br>';
//var_dump($fruits);


/*
Обычно для доступа к элементам массива используются переменные
*/

//$i = 2;
//$fruits = ['apple', 'orange', 'banana'];
//echo $fruits[$i];


// Или так

//$i = 1;
//$j = 1;
//$fruits = ['apple', 'orange', 'banana'];
//echo $fruits[$i + $j];


/*
Всё потому что внутри квадратных скобок ожидается "выражение"
Выражение - это то что вычисляется

Для получения последнего элемента массива используется выражение: размерМассива - 1
*/

//$fruits = ['apple', 'orange', 'banana'];
//echo $fruits[count($fruits) - 1];

/*
Чтобы изменить значение элемента массива, указываем конкретный индекс и присваиваем новое значение (принцип как с переменными)
*/

//$fruits = ['apple', 'orange', 'banana'];
//$fruits[1] = 'mango';
//print_r($fruits);


/*
Добавление нового элемента в массив
*/

//$fruits = ['apple', 'orange', 'banana'];
//$fruits[] = 'mango';// append
//$fruits[] = 'pineaple';// append
//print_r($fruits);



/*
Удаление элемента из массива
Используем специальную конструкцию в языке
unset(mixed $var, mixed ...$vars): void
*/

//$fruits = ['apple', 'orange', 'banana'];
//unset($fruits[1]);
//var_dump($fruits);

/*
Проверка на наличие элемента в массиве по конкретному индексу
Если пытаться выбрать элемент, которого нет в массиве, то будет выдан Notice. Поэтому лучше всегда проверять на наличие
Для этого есть готовая функция
array_key_exists — Проверяет, присутствует ли в массиве указанный ключ или индекс
array_key_exists(string|int $key, array $array): bool
*/

//$integers = [1, 3, 2];
//
//if (array_key_exists(1, $integers)) {
//    print_r('yeah!');
//} else {
//    print_r('no');
//}



/*
можно попробовать использовать isset()
но поведение функций разное, если в массиве под индексом окажется значение элемента = null
поэтому, лучше всегда использовать array_key_exists
*/

//$integers = [1, 3, 2, 4, null];
//
//if (isset($integers[4])) {
//    print_r('yeah!');
//} else {
//    print_r('no');
//}

// в массиве есть элемент под индексом 4, но значение = null, поэтому isset возвращает false

/*
При работе с массивами, практически всегда приходится использовать итерацию по элементам
И самый распространённый вариант - это циклы
*/

//$fruits = ['apple', 'orange', 'banana'];
//
//for ($i = 0; $i < count($fruits); $i++) {
//    print_r("{$fruits[$i]}<br>");
//}

/*
В цикле есть счётчик $i
Его используем как индекс массива и тем самым пробегаемся по каждому элементу
В самом начале мы задаём первое значение, а это 0, то есть самый первый элемент массива
указываем условие, по которому заходим внутрь цикла, то есть если $i меньше размера массива, почему?
потому что индекс последнего элемента массива меньше на единицу размера массива
в данном случае размер массива = 3
индекс последнего элемента = 2
и указываем принцип работы счётчика: $i++
мы уже знаем что это постфиксный инкремент
то есть, внутри цикла $i = 0, по завершению итерации цикла $i станет больше на единицу, $i = 1 и тд


Можно пробегаться по массиву в обратном порядке
цикл FOR позволяет это сделать
*/

//$fruits = ['apple', 'orange', 'banana'];
//
//for ($i = count($fruits) - 1; $i >= 0; $i--) {
//    print_r("{$fruits[$i]}<br>");
//}

/*
в данном случае счётчику даём индекс последнего элемента
в условие цикла указываем то, что ещё не достигнут первый элемент массива, то есть индекс больше или равен 0
когда он станет меньше 0, цикл завершится
а также здесь используется декремент, который уменьшае $i на единицу в конце каждой итерации цикла


Пример изменения элементов в цикле
*/

//$emails = ['ASKAR@gmAil.com', 'eGov.rk.KZ@gmail.com', 'MyBestEmailForever@Mail.KZ'];
//print_r($emails);
//echo '<br>';
//
//for ($i = 0; $i < count($emails); $i++) {
//    $emails[$i] = strtolower($emails[$i]);
//}
//
//print_r($emails);

/*
Ещё раз про FOR
в круглых скобках располагаются три блока выражений, разделяются они ;
первый блок - инициализация, выполняется только 1 раз
второй блок - условие выполнения цикла и содержит выражение, оно вычисляется перед каждой итерацией
цикл продолжается если выражение возвращает true, иначе цикл завершается
третьий блок - выражение, которое обрабатывается в конце итерации цикла, обычно это изменение значения счётчика, инкремент или декремент
*/

//$fruits = ['apple', 'orange', 'banana'];
//$length = count($fruits);
//
//for ($i = 0; $i < $length; $i++) {
//    print_r("{$fruits[$i]}<br>");
//}

/*
есть ещё более короткое и оптимальное исполнение
 */

//$fruits = ['apple', 'orange', 'banana'];
//
//for ($i = 0, $length = count($fruits), print 'init<br>'; $i < $length; print($i).'<br>', $i++) {
//    print_r("{$fruits[$i]}<br>");
//}



/*
FOREACH
foreach значительно проще for
В нём нет счётчика, условия цикла и изменение счётчика
*/

//$fruits = ['apple', 'orange', 'banana'];
//
//foreach ($fruits as $fruit) {
//    print_r($fruit.'<br>');
//}



/*
Если нужен индекс массива, есть такое написание
*/

//$fruits = ['apple', 'orange', 'banana'];
//
//foreach ($fruits as $index => $fruit) {
//    print_r("{$index}: {$fruit}<br>");
//}


//$fruits = ['apples', 'banana', 'mango'];
//
//foreach ($fruits as $fruit) {
//    if ($fruit == 'banana') {
//        break;
//    }
//    print($fruit.'<br>');
//}

//$i = 1;
//
//if ($i == 0) {
//    echo '0';
//} elseif ($i == 1) {
//    echo '1';
//} elseif($i == 2 || $i == 3 || $i == 4) {
//    echo '1';
//} else {
//    echo 'else';
//}
//
//switch ($i) {
//    case '1':
//        echo '1';
//        break;
//    case 2:
//        echo '2';
//        break;
//    case '3':
//    case '4':
//    case '5':
//        echo '345';
//        break;
//    default:
//        echo 'default';
//}
//$i = 1;
//
//switch ($i) {
//    case $i % 2 == 0:
//        echo "i равно 0";
//        break;
//    case $i % 3 == 0:
//        echo "i равно 1";
//        break;
//    case 2:
//        echo "i равно 2";
//        break;
//    default:
//        echo "i равно 111";
//        break;
//}
































